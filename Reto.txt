Reto Principal 1 : Sincronización de Mensajes Manuales del Agente con el Contexto del Asistente de OpenAI en un Bot de WhatsApp (BuilderBot + Baileys)

Contexto del Bot:

Stack: Node.js con TypeScript.
Framework del Bot: @builderbot/bot.
Proveedor de WhatsApp: @builderbot/provider-baileys (usa Baileys).
IA Conversacional: Asistente de OpenAI (@builderbot-plugins/openai-assistants que usa la API de Assistants, Threads, Runs y Messages).
Base de Datos de Estado: @builderbot/bot MemoryDB.
Flujo Principal: Los mensajes entrantes de clientes (EVENTS.WELCOME) son manejados por un flujo (mainFlow). Se implementó una lógica para agrupar mensajes rápidos de un mismo cliente (espera X segundos de inactividad antes de procesar el conjunto).
Procesamiento Secuencial: Un sistema de cola (userQueues) y bloqueo (userLocks) por usuario asegura que las interacciones con el Asistente de OpenAI para un mismo cliente sean secuenciales, utilizando un cooldown (OPENAI_COOLDOWN_MS) entre ellas para evitar errores de "run activo" de OpenAI.
El Reto Específico:

Cuando un agente humano (el "encargado") responde manualmente a un cliente utilizando la misma cuenta de WhatsApp del bot (por ejemplo, a través de WhatsApp Web o la app móvil), esos mensajes manuales del agente no se reflejan automáticamente en el historial del "Thread" del Asistente de OpenAI para ese cliente.

Esto causa problemas de contexto:

El agente envía manualmente información crucial al cliente (ej: "El precio especial para ti es $100").
El cliente responde a ese mensaje manual (ej: "¡Perfecto! Lo tomo").
Este mensaje del cliente llega al bot.
El bot lo pasa al Asistente de OpenAI.
El Asistente de OpenAI no tiene idea del mensaje manual del agente, por lo que la respuesta del cliente ("¡Perfecto! Lo tomo") le parece descontextualizada o referida a una interacción anterior del bot, llevando a respuestas incorrectas o confusas.
Objetivo Deseado: Que los mensajes enviados manualmente por el agente al cliente, desde la misma cuenta de WhatsApp, se "sincronicen" o se añadan al Thread de OpenAI correspondiente a ese cliente, para que el Asistente tenga el contexto completo de la conversación.

Intentos Realizados y Observaciones:

Intento Inicial (Fallido) de Captura en mainFlow:

Se observó que, en una configuración anterior muy básica, los mensajes manuales del agente (key.fromMe === true) llegaban a activar el flujo principal del bot (EVENTS.WELCOME). Sin embargo, esto causaba que el bot se respondiera a sí mismo, ya que no se distinguía correctamente si el mensaje fromMe: true era del propio bot (programático) o del agente manual.
En la versión actual del código, mainFlow (asociado a EVENTS.WELCOME) parece estar procesando principalmente (o únicamente) mensajes con key.fromMe === false (mensajes entrantes de clientes). Se añadió una guarda explícita if (ctx.key.fromMe) return; en mainFlow para asegurar esto y evitar bucles si EVENTS.WELCOME llegara a activarse por mensajes fromMe:true.
Intento Actual: Listener Directo de Eventos Baileys ('messages.upsert')

Lógica: Se añadió un listener directamente al emisor de eventos del proveedor Baileys (provider.vendor.ev.on('messages.upsert', ...)) dentro de la función main, después de que createBot inicializa el proveedor y este establece la conexión (connection === 'open').
Identificación del Mensaje del Agente:
Se filtra por mensajes con msg.key.fromMe === true.
Se requiere que el agente humano utilice un prefijo especial (ej: ENCARGADO_SYNC_PREFIX = "[SYNC]") al inicio de sus mensajes manuales para que el bot los identifique como mensajes a sincronizar.
Pero esto no ha funcionado ni co prefijo [SYNC]
Proceso de Sincronización (Teórico):
Si se detecta un mensaje fromMe: true con el prefijo:
Se extrae el JID del cliente (destinatario msg.key.remoteJid).
Se extrae el contenido del mensaje (sin el prefijo).
Se intenta obtener el thread_id de OpenAI para ese cliente desde adapterDB.get(clienteJid), asumiendo que el plugin @builderbot-plugins/openai-assistants lo almacena en el estado del cliente bajo una clave conocida (ej: OPENAI_THREAD_ID_KEY = 'thread_id').
Se utiliza el SDK de OpenAI (openai.beta.threads.messages.create(threadId, { role: 'assistant', content: ... })) para añadir este mensaje del agente al Thread del cliente.
Estado Actual del Intento (Según el último log):
El log [WARN] [MAIN_INIT]: adapterProvider.vendor.ev no disponible o SDK de OpenAI no inicializado. No se puede suscribir a 'messages.upsert'. apareció.
Esto se corrigió esperando el evento 'connection.update' con connection === 'open' antes de adjuntar el listener de 'messages.upsert', y utilizando la instancia provider devuelta por createBot. Este punto (la correcta suscripción) debería estar resuelto con el último código proporcionado.
El reto principal ahora es asegurar que el listener 'messages.upsert' efectivamente capture los mensajes del agente y pueda realizar la sincronización con el Thread de OpenAI. La efectividad de esto depende de:
Que el agente use el prefijo consistentemente.
Que podamos recuperar correctamente el thread_id del cliente desde adapterDB (es decir, que sepamos la clave correcta y que el estado esté accesible y poblado).
Que el SDK de OpenAI esté correctamente inicializado con la OPENAI_API_KEY.
Puntos Adicionales Implementados (Relacionados pero no el foco principal del reto actual):

Agrupación de Mensajes del Cliente: Los mensajes de clientes (fromMe: false) que llegan en ráfagas rápidas se agrupan usando un temporizador de inactividad (USER_INACTIVITY_TIMEOUT_MS, actualmente en 6 segundos) antes de ser enviados a OpenAI. Esto funciona bien.
Contexto para el Asistente sobre Intervención Manual: Si el bot indica que "un encargado responderá", establece un flag en el estado del cliente (esperando_respuesta_encargado). Cuando el cliente vuelve a escribir, se añade una nota al prompt enviado a OpenAI para que considere que pudo haber una conversación manual intermedia. Esto es un paliativo si la sincronización directa del mensaje del agente falla.
Básicamente, el desafío es cómo hacer que el bot "escuche" y "registre" de forma fiable los mensajes que un humano envía desde la misma cuenta de WhatsApp, para que la IA conversacional (Asistente de OpenAI) mantenga un contexto completo. El método actual se basa en un listener de bajo nivel de Baileys y un prefijo en los mensajes del agente.

código actual

import "dotenv/config"
import OpenAI from 'openai'; // Para interactuar directamente con API de OpenAI
import { createBot, createProvider, createFlow, addKeyword, EVENTS } from '@builderbot/bot'
import { MemoryDB } from '@builderbot/bot'
import { BaileysProvider } from '@builderbot/provider-baileys'
import { toAsk, httpInject } from "@builderbot-plugins/openai-assistants"

// --- Constantes ---
const PORT = process.env.PORT ?? 3008;
const ASSISTANT_ID = process.env.ASSISTANT_ID ?? '';
const OPENAI_API_KEY = process.env.OPENAI_API_KEY ?? ''; // Necesaria para el SDK

const CHUNK_DELAY_MS = 150;
const OPENAI_COOLDOWN_MS = 3000;
const CLEAN_REGEX = /【.*?】[ ]?/g;
const USER_INACTIVITY_TIMEOUT_MS = 6000; // Ajustado a 6 segundos
const ENCARGADO_SYNC_PREFIX = "[SYNC]";
const OPENAI_THREAD_ID_KEY = 'thread_id'; // Clave para el thread_id en el state (confirmar si es esta)

// --- SDK de OpenAI ---
let openai: OpenAI;
if (OPENAI_API_KEY) {
    openai = new OpenAI({ apiKey: OPENAI_API_KEY });
} else {
    // Este console.error se mostrará antes que los customLog si OPENAI_API_KEY falta al inicio
    console.error("CRITICAL_ENV_ERROR: OPENAI_API_KEY no está configurada en el archivo .env. La funcionalidad de sincronización de mensajes de encargado y OpenAI no operará.");
    // Considerar salir si es crítico: process.exit(1);
}

// --- Almacenamiento para colas y bloqueos ---
const userQueues = new Map<string, Array<any>>();
const userLocks = new Map<string, boolean>();

interface UserMessageBuffer {
    messages: string[];
    lastCtx: any;
    flowDynamic: any;
    state: any; 
    provider: any;
}
const userMessageBuffers = new Map<string, UserMessageBuffer>();
const userActivityTimers = new Map<string, NodeJS.Timeout>();

// --- Funciones de Logging Personalizadas ---
const getFormattedTimestamp = (): string => {
    const now = new Date();
    const dateOptions: Intl.DateTimeFormatOptions = { year: '2-digit', month: '2-digit', day: '2-digit' };
    const timeOptions: Intl.DateTimeFormatOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
    const date = now.toLocaleDateString('es-CO', dateOptions);
    const time = now.toLocaleTimeString('es-CO', timeOptions);
    const ms = String(now.getMilliseconds()).padStart(3, '0');
    return `${date} ${time}.${ms}`;
};

const customLog = (level: 'INFO' | 'WARN' | 'ERROR' | 'DEBUG', context: string, ...messages: any[]) => {
    const timestamp = getFormattedTimestamp();
    const messageParts = messages.map(msg => {
        if (msg instanceof Error) return msg.stack || msg.message;
        if (typeof msg === 'object' && msg !== null) {
            try { return JSON.stringify(msg, null, 2); } catch (e) { return '[Objeto no serializable]'; }
        }
        return String(msg);
    });
    const logLine = `[${timestamp}] [${level}] ${context}: ${messageParts.join(' ')}`;
    switch (level) {
        case 'INFO': console.log(logLine); break;
        case 'WARN': console.warn(logLine); break;
        case 'ERROR': console.error(logLine); break;
        case 'DEBUG': console.debug(logLine); break; // Añadido para logs de depuración
    }
};

// --- Funciones de Ayuda ---
const getShortUserId = (ctxOrUserId: any): string => {
    if (typeof ctxOrUserId === 'string') return ctxOrUserId.split('@')[0] || ctxOrUserId;
    return ctxOrUserId?.from?.split('@')[0] || ctxOrUserId?.from || ctxOrUserId?.key?.remoteJid?.split('@')[0] || 'unknownUser';
};

const extractTextFromMessage = (msg: any): string | null => {
    if (!msg || !msg.message) return null;
    return msg.message.conversation ||
           msg.message.extendedTextMessage?.text ||
           msg.message.ephemeralMessage?.message?.extendedTextMessage?.text ||
           msg.message.ephemeralMessage?.message?.conversation ||
           null;
};

// --- Función de Typing ---
const typing = async (ctx: any, provider: any): Promise<void> => {
    const remoteJid = ctx.key?.remoteJid;
    const shortUserId = getShortUserId(ctx.from || ctx.key.remoteJid); // ctx.from para entrantes, ctx.key.remoteJid para salientes
    const logContext = `TYPING [${shortUserId}]`;

    if (provider?.vendor?.sendPresenceUpdate && typeof provider.vendor.sendPresenceUpdate === 'function') {
        if (remoteJid) {
            try {
                await provider.vendor.sendPresenceUpdate('composing', remoteJid);
            } catch (e) {
                customLog('ERROR', logContext, `Error al enviar 'composing':`, e);
            }
        } else {
            // No siempre es un error, podría ser un mensaje sin remoteJid claro en ese contexto.
            // customLog('WARN', logContext, `ctx.key.remoteJid no disponible.`);
        }
    }
};

/**
 * Procesa el mensaje del usuario interactuando con OpenAI y enviando la respuesta.
 */
const processUserMessage = async (ctx: any, { flowDynamic, state, provider }: any) => {
    const shortUserId = getShortUserId(ctx.from);
    const logContext = `PROCESS_MSG [${shortUserId}]`;
    let mensajeParaOpenAI = ctx.body;

    const esperandoEncargado = await state.get('esperando_respuesta_encargado');
    if (esperandoEncargado) {
        const temaConsulta = await state.get('tema_consulta_encargado') || 'un tema previo';
        const notaContextual = `[Nota para el Asistente: El usuario podría estar respondiendo a información proporcionada manualmente por un encargado sobre "${temaConsulta}". Por favor, ten esto en cuenta al generar tu respuesta.]\n\n`;
        mensajeParaOpenAI = notaContextual + ctx.body;
        customLog('INFO', logContext, `Añadiendo nota contextual para OpenAI sobre "${temaConsulta}".`);
        await state.update({ esperando_respuesta_encargado: false, tema_consulta_encargado: null });
    }

    customLog('INFO', logContext, `Iniciando procesamiento OpenAI para: "${mensajeParaOpenAI.substring(0,100)}..."`);
    await typing(ctx, provider);

    customLog('INFO', logContext, `Solicitando respuesta a OpenAI Assistant (${ASSISTANT_ID.substring(0,10)})...`);
    const response = await toAsk(ASSISTANT_ID, mensajeParaOpenAI, state);
    customLog('INFO', logContext, `Respuesta de OpenAI recibida: "${response.substring(0,50)}..."`);

    const chunks = response.split(/\n\n+/);
    for (const chunk of chunks) {
        const cleanedChunk = chunk.trim().replace(CLEAN_REGEX, "");
        if (cleanedChunk) {
            customLog('INFO', logContext, `Enviando chunk: "${cleanedChunk.substring(0, 50)}..."`);
            await flowDynamic([{ body: cleanedChunk }]);
            
            if (cleanedChunk.toLowerCase().includes("espere, me comunico con el encargado") || 
                cleanedChunk.toLowerCase().includes("confirmo con encargado") ||
                cleanedChunk.toLowerCase().includes("confirmo los precios en el sistema y le aviso")) {
                let tema = "información general";
                const originalUserQuery = ctx.body; 
                if (originalUserQuery.toLowerCase().includes("precio")) tema = "precios";
                if (originalUserQuery.toLowerCase().includes("disponibilidad")) tema = "disponibilidad";
                if (originalUserQuery.toLowerCase().includes("ubicado") || originalUserQuery.toLowerCase().includes("distancia")) tema = "ubicación";
                
                await state.update({ esperando_respuesta_encargado: true, tema_consulta_encargado: tema });
                customLog('INFO', logContext, `Bot indicó comunicación con encargado sobre tema "${tema}". Estado 'esperando_respuesta_encargado' activado para ${shortUserId}.`);
            }
            await new Promise(resolve => setTimeout(resolve, CHUNK_DELAY_MS));
        }
    }
    customLog('INFO', logContext, `Todos los chunks enviados para el mensaje original del cliente: "${ctx.body.substring(0,30)}..."`);
};

// --- Manejo de Cola (handleQueue) ---
const handleQueue = async (userId: string) => {
    const queue = userQueues.get(userId);
    const shortUserId = getShortUserId(userId);
    const logContext = `HANDLE_QUEUE [${shortUserId}]`;

    if (!queue) {
        customLog('INFO', logContext, `No se encontró cola.`);
        userLocks.delete(userId);
        return;
    }
    
    if (userLocks.get(userId)) {
        customLog('INFO', logContext, `La cola está bloqueada.`);
        return;
    }

    while (queue.length > 0) {
        if (userLocks.get(userId)) {
            customLog('INFO', logContext, `Bloqueo activado en bucle.`);
            return;
        }
        userLocks.set(userId, true);
        customLog('INFO', logContext, `Bloqueo adquirido.`);
        const task = queue.shift();

        if (task) {
            const { ctx, flowDynamic, state, provider } = task; 
            customLog('INFO', logContext, `Procesando tarea. Restantes: ${queue.length}. Msg: "${String(ctx.body).substring(0,100)}..."`);
            try {
                await processUserMessage(ctx, { flowDynamic, state, provider });
                customLog('INFO', logContext, `Tarea completada.`);
            } catch (error: any) {
                const errorMessage = error.message || String(error);
                customLog('ERROR', logContext, `Error en tarea para msg "${String(ctx.body).substring(0,30)}...":`, error);
                if (errorMessage.includes("while a run") && errorMessage.includes("is active")) {
                    customLog('ERROR', logContext, `OpenAI Run activo. Cooldown actual: ${OPENAI_COOLDOWN_MS}ms.`);
                }
            } finally {
                userLocks.set(userId, false);
                customLog('INFO', logContext, `Bloqueo liberado.`);
                if (queue.length > 0) {
                    customLog('INFO', logContext, `${queue.length} en cola. Cooldown ${OPENAI_COOLDOWN_MS}ms.`);
                    await new Promise(resolve => setTimeout(resolve, OPENAI_COOLDOWN_MS));
                }
            }
        } else {
            userLocks.set(userId, false);
            customLog('WARN', logContext, `Bloqueo liberado (tarea nula).`);
            break; 
        }
    }

    if (queue.length === 0 && !userLocks.get(userId)) {
        userQueues.delete(userId);
        userLocks.delete(userId);
        customLog('INFO', logContext, `Cola vacía y desbloqueada. Limpiada.`);
    } else if (queue.length === 0 && userLocks.get(userId)) {
        customLog('WARN', logContext, `Cola vacía pero aún bloqueada.`);
    } else if (queue.length > 0 && !userLocks.get(userId)) {
        customLog('INFO', logContext, `${queue.length} en cola y desbloqueada. Siguiente handleQueue lo tomará.`);
    }
};

// --- Flujo Principal ---
const mainFlow = addKeyword<BaileysProvider, MemoryDB>(EVENTS.WELCOME)
    .addAction(async (ctx, args) => {
        if (ctx.key.fromMe) {
            // customLog('DEBUG', `MAIN_FLOW [from:${getShortUserId(ctx.from)}]`, `Mensaje 'fromMe:true' detectado en mainFlow (EVENTS.WELCOME). Ignorando, ya que debe ser manejado por 'messages.upsert' si es del encargado, o es un eco del propio bot.`);
            return;
        }

        const { flowDynamic, state, provider } = args;
        const clientId = ctx.from;
        const shortClientId = getShortUserId(clientId);
        const currentMessageBody = ctx.body;
        const logContextClient = `CLIENT_MSG_HANDLER [from:${shortClientId}]`;

        customLog('INFO', logContextClient, `Mensaje de cliente "${currentMessageBody.substring(0,30)}..." recibido.`);

        let userBuffer = userMessageBuffers.get(clientId);
        if (!userBuffer) {
            userBuffer = { messages: [], lastCtx: ctx, flowDynamic, state, provider };
            userMessageBuffers.set(clientId, userBuffer);
            customLog('INFO', logContextClient, `Nuevo buffer de mensajes creado para cliente.`);
        }
        
        userBuffer.messages.push(currentMessageBody);
        userBuffer.lastCtx = ctx;
        userBuffer.flowDynamic = flowDynamic;
        userBuffer.state = state; 
        userBuffer.provider = provider;

        customLog('INFO', logContextClient, `Mensaje añadido al buffer del cliente. Total en buffer: ${userBuffer.messages.length}.`);

        if (userActivityTimers.has(clientId)) {
            clearTimeout(userActivityTimers.get(clientId)!);
        }

        const timerId = setTimeout(async () => {
            const finalBuffer = userMessageBuffers.get(clientId);
            if (finalBuffer && finalBuffer.messages.length > 0) {
                const combinedMessageBody = finalBuffer.messages.join('\n\n');
                const taskCtx = { ...finalBuffer.lastCtx, body: combinedMessageBody };
                const taskState = finalBuffer.state;

                if (!userQueues.has(clientId)) {
                    userQueues.set(clientId, []);
                }
                const queue = userQueues.get(clientId)!;
                queue.push({ 
                    ctx: taskCtx, 
                    flowDynamic: finalBuffer.flowDynamic, 
                    state: taskState, 
                    provider: finalBuffer.provider 
                });
                customLog('INFO', `USER_ACTIVITY_TIMEOUT [from:${shortClientId}]`, `${finalBuffer.messages.length} msgs combinados y encolados: "${combinedMessageBody.substring(0,100)}..."`);

                if (!userLocks.get(clientId)) {
                    customLog('INFO', `USER_ACTIVITY_TIMEOUT [from:${shortClientId}]`, `Cola principal no bloqueada. Iniciando handleQueue.`);
                    handleQueue(clientId);
                } else {
                    customLog('INFO', `USER_ACTIVITY_TIMEOUT [from:${shortClientId}]`, `Cola principal bloqueada. Msg combinado esperará.`);
                }
            }
            userMessageBuffers.delete(clientId);
            userActivityTimers.delete(clientId);
        }, USER_INACTIVITY_TIMEOUT_MS);

        userActivityTimers.set(clientId, timerId);
        customLog('INFO', logContextClient, `Temporizador de inactividad (${USER_INACTIVITY_TIMEOUT_MS / 1000}s) iniciado/reiniciado para cliente.`);
    });

// --- Función Principal (main) ---
const main = async () => {
    const logContext = `[MAIN_INIT]`;
    customLog('INFO', logContext, `Iniciando el bot en el puerto ${PORT}`);
    if (!ASSISTANT_ID) {
        customLog('ERROR', logContext, `CRITICAL: La variable de entorno ASSISTANT_ID no está configurada. Saliendo.`);
        process.exit(1);
    }
    if (!OPENAI_API_KEY || !openai) { // Chequeo si el SDK de OpenAI se pudo inicializar
        customLog('ERROR', logContext, `CRITICAL: OPENAI_API_KEY no configurada o SDK de OpenAI no inicializado. Sincronización de encargado no funcionará. Saliendo.`);
        process.exit(1); // Salir si es crítico
    }
    customLog('INFO', logContext, `Usando Assistant ID: ${ASSISTANT_ID.substring(0,10)}...`);
    customLog('INFO', logContext, `OpenAI Cooldown: ${OPENAI_COOLDOWN_MS}ms.`);
    customLog('INFO', logContext, `User Inactivity Timeout (Msg Grouping): ${USER_INACTIVITY_TIMEOUT_MS}ms.`);
    customLog('INFO', logContext, `Encargado Sync Prefix: "${ENCARGADO_SYNC_PREFIX}"`);

    const adapterFlow = createFlow([mainFlow]);
    const baseAdapterProvider = createProvider(BaileysProvider, { groupsIgnore: true, readStatus: false });
    const adapterDB = new MemoryDB(); 

    const { httpServer, provider } = await createBot({
        flow: adapterFlow,
        provider: baseAdapterProvider,
        database: adapterDB,
    });

    // Listener para 'messages.upsert' usando la instancia 'provider' de createBot
    if (provider?.vendor?.ev && openai) {
        customLog('INFO', logContext, "Preparando suscripción a 'connection.update' del proveedor Baileys.");
        
        provider.vendor.ev.on('connection.update', async (update: any) => {
            const { connection } = update;
            const connLogContext = `${logContext} [Baileys Connection]`;
            if (connection === 'open') {
                customLog('INFO', connLogContext, "Conexión abierta. Suscribiéndose ahora a 'messages.upsert'.");

                provider.vendor.ev.removeAllListeners('messages.upsert'); // Prevenir duplicados en reconexión
                provider.vendor.ev.on('messages.upsert', async ({ messages, type }) => {
                    const upsertLogContext = `MESSAGES_UPSERT_HANDLER`;
                    // customLog('DEBUG', upsertLogContext, `Evento: ${type}, Mensajes: ${messages.length}`);

                    for (const msg of messages) {
                        if (!msg.message || msg.key.remoteJid === 'status@broadcast') continue;
                        const messageBody = extractTextFromMessage(msg);

                        if (msg.key.fromMe && messageBody) {
                            const recipientJid = msg.key.remoteJid;
                            const shortRecipientJid = getShortUserId(recipientJid);
                            const currentMsgContext = `${upsertLogContext} [to:${shortRecipientJid}]`;

                            customLog('DEBUG', currentMsgContext, `Mensaje 'fromMe' detectado. Body: "${messageBody.substring(0, 60)}..."`);

                            if (messageBody.startsWith(ENCARGADO_SYNC_PREFIX)) {
                                customLog('INFO', currentMsgContext, `Prefijo SYNC de encargado detectado.`);
                                const encargadoMessageContent = messageBody.substring(ENCARGADO_SYNC_PREFIX.length).trim();
                                
                                if (!encargadoMessageContent) {
                                    customLog('WARN', currentMsgContext, `Mensaje SYNC del encargado está vacío.`);
                                    continue;
                                }
                                try {
                                    const clientStateObject = await adapterDB.get(recipientJid);
                                    if (!clientStateObject || typeof clientStateObject !== 'object') {
                                        customLog('WARN', currentMsgContext, `No se encontró estado o no es un objeto para cliente ${shortRecipientJid}. No se puede sincronizar.`);
                                        continue;
                                    }
                                    const threadId = clientStateObject[OPENAI_THREAD_ID_KEY];
                                    if (!threadId) {
                                        customLog('WARN', currentMsgContext, `No se encontró thread_id (key: ${OPENAI_THREAD_ID_KEY}) en estado de ${shortRecipientJid}.`);
                                        continue;
                                    }
                                    customLog('INFO', currentMsgContext, `Añadiendo mensaje de encargado al thread ${threadId}: "${encargadoMessageContent.substring(0,50)}"`);
                                    await openai.beta.threads.messages.create(threadId, {
                                        role: 'assistant', 
                                        content: encargadoMessageContent
                                    });
                                    customLog('INFO', currentMsgContext, `Mensaje de encargado sincronizado con OpenAI para ${shortRecipientJid}.`);
                                } catch (e: any) {
                                    customLog('ERROR', currentMsgContext, `Error sincronizando mensaje de encargado para ${shortRecipientJid}:`, e.message, e.stack);
                                }
                            }
                        }
                    }
                });
            } else if (connection === 'close') {
                 customLog('WARN', connLogContext, "Conexión cerrada.");
            }
        });
    } else {
        let reason = "";
        if (!openai) reason += "SDK de OpenAI no inicializado. ";
        if (!provider?.vendor?.ev) reason += "provider.vendor.ev no disponible. ";
        customLog('WARN', logContext, `No se puede configurar listener para 'messages.upsert'. Razón: ${reason.trim()}`);
    }

    // httpInject ahora usa 'baseAdapterProvider' porque 'provider.server' podría no ser el servidor HTTP que espera httpInject.
    // Generalmente, el httpInject se aplica al servidor que Baileys/Venom crea, que está en la instancia original.
    if (baseAdapterProvider.server && typeof httpInject === 'function') {
        httpInject(baseAdapterProvider.server);
        customLog('INFO', logContext, `Inyección HTTP para el proveedor aplicada.`);
    } else {
        customLog('WARN', logContext, `No se pudo aplicar inyección HTTP al proveedor (baseAdapterProvider.server no disponible o httpInject no es función).`);
    }

    if (httpServer && typeof httpServer === 'function') {
        httpServer(Number(PORT));
        customLog('INFO', logContext, `Llamada a httpServer(${PORT}) realizada.`);
    } else {
        customLog('ERROR', logContext, `httpServer no es una función o no se obtuvo.`);
    }
};

main().catch(err => {
    customLog('ERROR', `[MAIN_INIT]`, `Error fatal al iniciar bot:`, err);
    process.exit(1);
});

---

