# Nuevo Reto: Sistema de Persistencia de Conversaciones a Largo Plazo

## Descripción del Reto

Actualmente, nuestro sistema funciona correctamente para mantener el contexto de conversación dentro de una sesión activa, pero toda esta información se pierde cuando el bot se reinicia o después de períodos prolongados sin interacción. El próximo reto consiste en implementar un sistema de almacenamiento persistente que permita al bot "recordar" conversaciones anteriores con clientes, incluso después de meses o años.

## Problemas a Resolver

1. **Pérdida de contexto histórico**: Actualmente, si un cliente contacta nuevamente después de semanas, el bot lo trata como un cliente nuevo.

2. **Limitación del almacenamiento en memoria**: El mapa `clientThreadMap` actual solo mantiene los thread_ids en memoria, perdiéndose al reiniciar el sistema.

3. **Falta de referencias cruzadas**: No existe forma de relacionar conversaciones pasadas con las actuales para mejorar la experiencia del cliente.

4. **Imposibilidad de análisis a largo plazo**: No se pueden analizar patrones de comunicación o preferencias de los clientes a lo largo del tiempo.

## Solución Propuesta

### 1. Arquitectura de Base de Datos

Implementar una base de datos persistente (MongoDB, PostgreSQL o similar) con dos colecciones/tablas principales:

**ClientThreads**:
```
{
  phoneNumber: "573003913251",       // Identificador principal
  currentThreadId: "thread_xyz...",  // Thread actual de OpenAI
  lastInteraction: Date,             // Timestamp de última actividad
  totalInteractions: Number,         // Contador de conversaciones
  customerName: String,              // Nombre del cliente (si se conoce)
  tags: [String],                    // Etiquetas para categorizar al cliente
  conversationSummary: String        // Resumen generado de la conversación
}
```

**ConversationHistory**:
```
{
  phoneNumber: "573003913251",      // Vinculación con el cliente
  timestamp: Date,                  // Momento del mensaje
  threadId: "thread_xyz...",        // Para agrupar conversaciones
  role: "user"|"assistant"|"manual_operator",
  content: String,                  // Contenido del mensaje
  metadata: {                       // Datos adicionales
    sentiment: String,              // Análisis de sentimiento opcional
    topics: [String],               // Temas detectados en el mensaje
    intentType: String              // Clasificación de intención
  }
}
```

### 2. Integración con el Flujo Actual

Modificar las funciones clave para trabajar con la base de datos:

```javascript
// Reemplazar el mapa en memoria actual
// const clientThreadMap = {};

// Funciones modificadas
async function saveThreadId(jid, threadId) {
  const phoneNumber = getShortUserId(jid);
  await db.ClientThreads.updateOne(
    { phoneNumber },
    { 
      $set: { currentThreadId: threadId, lastInteraction: new Date() },
      $inc: { totalInteractions: 1 },
      $setOnInsert: { createdAt: new Date() }
    },
    { upsert: true }
  );
  
  log('THREAD_SAVE', 'INFO', `Thread ID ${threadId} guardado para ${phoneNumber} en DB`);
  return true;
}

async function getThreadId(jid) {
  const phoneNumber = getShortUserId(jid);
  const clientData = await db.ClientThreads.findOne({ phoneNumber });
  return clientData?.currentThreadId || null;
}
```

### 3. Sistema de Contextualización Histórica

Implementar un sistema que inyecte contexto histórico relevante al inicio de nuevas conversaciones:

```javascript
async function enrichContextWithHistory(phoneNumber, state) {
  // Buscar datos del cliente
  const clientData = await db.ClientThreads.findOne({ phoneNumber });
  
  if (!clientData) return false; // Cliente nuevo
  
  // Si han pasado más de 30 días desde la última interacción
  const daysSinceLastInteraction = 
    (new Date() - new Date(clientData.lastInteraction)) / (1000 * 60 * 60 * 24);
  
  if (daysSinceLastInteraction > 30) {
    // Recuperar resumen de conversaciones previas
    const previousThreads = await db.ConversationHistory
      .distinct('threadId', { phoneNumber })
      .limit(3)
      .sort({ timestamp: -1 });
    
    // Crear mensaje de contexto para OpenAI
    const contextPrompt = `
      [NOTA DE SISTEMA: Este cliente (${phoneNumber}) ha interactuado con nosotros anteriormente. 
      Su última conversación fue hace ${Math.round(daysSinceLastInteraction)} días.
      Resumen de interacciones previas: ${clientData.conversationSummary || "No disponible"}
      Si el cliente tiene nombre registrado (${clientData.customerName || "No registrado"}), 
      utilízalo para personalizar el saludo.]
    `;
    
    // Inyectar este contexto en la próxima conversación
    await state.update({ 
      historical_context: contextPrompt,
      is_returning_customer: true 
    });
    
    return true;
  }
  
  return false;
}
```

### 4. Registrar Historial de Conversaciones

Guardar todos los mensajes intercambiados para análisis futuro:

```javascript
async function saveMessageToHistory(phoneNumber, role, content, threadId) {
  await db.ConversationHistory.insertOne({
    phoneNumber,
    timestamp: new Date(),
    threadId,
    role,
    content,
    metadata: {
      // Opcionalmente, analizar el mensaje para extraer más datos
      topics: extractTopics(content),
      intentType: classifyIntent(content)
    }
  });
}
```

### 5. Generación de Resúmenes Automáticos

Implementar un proceso que, al finalizar una conversación, genere un resumen para facilitar futuras interacciones:

```javascript
async function generateConversationSummary(phoneNumber, threadId) {
  // Recuperar todos los mensajes de esta conversación
  const messages = await db.ConversationHistory.find({ 
    phoneNumber, 
    threadId 
  }).sort({ timestamp: 1 }).toArray();
  
  // Usar OpenAI para generar resumen
  const prompt = `Resumir la siguiente conversación destacando:
  - Principales temas discutidos
  - Preferencias del cliente
  - Compromisos adquiridos
  - Estado final de la conversación
  
  Conversación:
  ${messages.map(m => `[${m.role}]: ${m.content}`).join('\n')}`;
  
  const response = await openai.createCompletion({
    model: "text-davinci-003",
    prompt,
    max_tokens: 250,
    temperature: 0.3
  });
  
  const summary = response.choices[0].text.trim();
  
  // Actualizar resumen en la ficha del cliente
  await db.ClientThreads.updateOne(
    { phoneNumber },
    { $set: { conversationSummary: summary } }
  );
}
```

## Beneficios Esperados

1. **Experiencia personalizada**: El bot podrá saludar a clientes recurrentes de forma personalizada, recordando sus preferencias y conversaciones anteriores.

2. **Continuidad en las interacciones**: Se evitará repetir información ya proporcionada anteriormente.

3. **Análisis de datos**: Posibilidad de extraer insights como:
   - Temas recurrentes de consulta
   - Patrones de comunicación por cliente
   - Efectividad de las respuestas del bot y operador

4. **Recuperación ante fallos**: El sistema podrá recuperar su estado después de reinicios o caídas.

5. **Mejora del servicio al cliente**: Los operadores humanos tendrán acceso al historial completo de interacciones al intervenir manualmente.

## Desafíos Técnicos

1. **Escalabilidad**: Diseñar la base de datos para manejar eficientemente miles o millones de conversaciones.

2. **Privacidad y seguridad**: Implementar medidas adecuadas para proteger la información de los clientes.

3. **Manejo del contexto**: Determinar qué información histórica es relevante para cada nueva conversación.

4. **Optimización de consultas**: Asegurar que la recuperación de datos históricos no impacte el rendimiento del bot.

5. **Mantenimiento**: Establecer políticas de retención y limpieza de datos antiguos.

Este reto llevará nuestro bot de WhatsApp a un nivel superior, proporcionando una experiencia verdaderamente personalizada y contextualizada para cada cliente, similar a la que ofrecería un asistente humano con excelente memoria y acceso a todas las interacciones previas.